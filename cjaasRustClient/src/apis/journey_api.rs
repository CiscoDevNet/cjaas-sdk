/*
 * Azure Functions OpenAPI Extension
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `create_journey_action`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateJourneyActionError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    Status422(crate::models::HttpErrorResponse),
    Status500(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_profile_view_template`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateProfileViewTemplateError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    Status422(crate::models::HttpErrorResponse),
    Status500(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_view`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateViewError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_journey_action`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteJourneyActionError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    Status500(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_profile_view_template`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteProfileViewTemplateError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    Status500(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_journey_action`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJourneyActionError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    Status404(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_journey_action_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJourneyActionListError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    Status404(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_profile_view_templates`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProfileViewTemplatesError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    Status404(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_report_by_name`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetReportByNameError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_view_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetViewStatusError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `post_events`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostEventsError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `profile_builder`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProfileBuilderError {
    Status400(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `read_events`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReadEventsError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `read_events_by_identity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReadEventsByIdentityError {
    Status400(crate::models::HttpErrorResponse),
    Status401(),
    Status403(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `read_streams`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReadStreamsError {
    Status400(),
    Status403(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `read_streams_by_person`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReadStreamsByPersonError {
    Status400(),
    Status403(crate::models::HttpErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Create/Replace Journey Action.   SAS Token Requirements:  - ss=action  - sp=w
pub async fn create_journey_action(configuration: &configuration::Configuration, authorization: &str, body: crate::models::JourneyAction) -> Result<crate::models::HttpSimpleMessageObjectResponse, Error<CreateJourneyActionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/actions", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateJourneyActionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create Profile View Template.   SAS Token Requirements:  - ss=profile  - sp=w
pub async fn create_profile_view_template(configuration: &configuration::Configuration, authorization: &str, body: crate::models::ProfileViewTemplateCreateModel) -> Result<crate::models::HttpSimpleMessageObjectResponse, Error<CreateProfileViewTemplateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/views/templates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateProfileViewTemplateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Starts job to generate Progressive Profile View for a person. The HTTP response is intended to be compatible with the Polling Consumer Pattern.   SAS Token Requirements:  - ss=profile  - p=w
pub async fn create_view(configuration: &configuration::Configuration, authorization: &str, view_id: &str, person_id: Option<&str>, search_filter: Option<&str>, skip_cache: Option<bool>, X_CACHE_MAXAGE_HOUR: Option<i32>, X_CACHE_MAXAGE_MIN: Option<i32>) -> Result<crate::models::CreateProgressiveProfileViewJobResponseModel, Error<CreateViewError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/views", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ViewId", &view_id.to_string())]);
    if let Some(ref local_var_str) = person_id {
        local_var_req_builder = local_var_req_builder.query(&[("PersonId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search_filter {
        local_var_req_builder = local_var_req_builder.query(&[("SearchFilter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = skip_cache {
        local_var_req_builder = local_var_req_builder.query(&[("SkipCache", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    if let Some(local_var_param_value) = X_CACHE_MAXAGE_HOUR {
        local_var_req_builder = local_var_req_builder.header("X-CACHE-MAXAGE-HOUR", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = X_CACHE_MAXAGE_MIN {
        local_var_req_builder = local_var_req_builder.header("X-CACHE-MAXAGE-MIN", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateViewError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Soft delete Journey Action.   SAS Token Requirements:  - ss=action  - sp=w
pub async fn delete_journey_action(configuration: &configuration::Configuration, authorization: &str, id: &str) -> Result<crate::models::HttpSimpleMessageObjectResponse, Error<DeleteJourneyActionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/actions/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteJourneyActionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete Profile View Template.   SAS Token Requirements:  - ss=profile  - sp=w
pub async fn delete_profile_view_template(configuration: &configuration::Configuration, authorization: &str, id: Option<&str>) -> Result<crate::models::HttpSimpleMessageObjectResponse, Error<DeleteProfileViewTemplateError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/views/templates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("Id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteProfileViewTemplateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get specific Journey Action.   SAS Token Requirements:  - ss=action  - sp=r
pub async fn get_journey_action(configuration: &configuration::Configuration, authorization: &str, id: &str) -> Result<crate::models::HttpGenericObjectResponseJourneyAction, Error<GetJourneyActionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/actions/{id}", configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetJourneyActionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all Journey Actions.   SAS Token Requirements:  - ss=action  - sp=r
pub async fn get_journey_action_list(configuration: &configuration::Configuration, authorization: &str, template_id: Option<&str>) -> Result<crate::models::HttpGenericListObjectResponseJourneyAction, Error<GetJourneyActionListError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/actions", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = template_id {
        local_var_req_builder = local_var_req_builder.query(&[("templateId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetJourneyActionListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all/specific Profile View Templates, available for usage by the CJaaS Org and Organization.  SAS Token Requirements:  - ss=profile  - sp=r
pub async fn get_profile_view_templates(configuration: &configuration::Configuration, authorization: &str, id: Option<&str>) -> Result<crate::models::HttpGenericListObjectResponseProfileViewTemplate, Error<GetProfileViewTemplatesError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/views/templates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("Id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetProfileViewTemplatesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a certain usage report.   SAS Token Requirements:  - ss=account  - sp=r
pub async fn get_report_by_name(configuration: &configuration::Configuration, authorization: &str, reportname: &str) -> Result<crate::models::HttpReportObjectResponse, Error<GetReportByNameError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/reports/{reportname}", configuration.base_path, reportname=crate::apis::urlencode(reportname));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetReportByNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the status of a Progressive Profile View Job.  SAS Token Requirements:  - ss=profile  - p=r
pub async fn get_view_status(configuration: &configuration::Configuration, authorization: &str, view_id: &str, instance_id: &str, person_id: Option<&str>, search_filter: Option<&str>) -> Result<(), Error<GetViewStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/views", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ViewId", &view_id.to_string())]);
    if let Some(ref local_var_str) = person_id {
        local_var_req_builder = local_var_req_builder.query(&[("PersonId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search_filter {
        local_var_req_builder = local_var_req_builder.query(&[("SearchFilter", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("instanceId", &instance_id.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetViewStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// API accepts events that describe what occurred, when, and by whom on every interaction across touch points and applications. Data Ingestion is based on Cloud Events specification for describing event data in a common way. API accepts data in the form of POST with support for Header based authorization.  SAS Token Requirements:  - ss=ds  - sp=w
pub async fn post_events(configuration: &configuration::Configuration, authorization: &str, body: crate::models::CloudEvent) -> Result<crate::models::HttpSimpleMessageObjectResponse, Error<PostEventsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/events/v1/journey", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostEventsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The profile view is created based on a view template that is provided as input.    **Sample request**: *GET /v1/journey/profileview?customer=123XX*    {    &nbsp;&nbsp;&nbsp;&nbsp;\"Name\": \"Test Template 2\",    &nbsp;&nbsp;&nbsp;&nbsp;\"DatapointCount\": 7,    &nbsp;&nbsp;&nbsp;&nbsp;\"Attributes\": [{    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Version\": \"0.1\",    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Event\": \"Add to Cart\",    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Metadata\": \"sku\",    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Limit\": 3,    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"DisplayName\": \"Items added\",    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Verbose\": false,    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"AggregationMode\": \"Value\"    &nbsp;&nbsp;&nbsp;&nbsp;}]    }.
pub async fn profile_builder(configuration: &configuration::Configuration, authorization: &str, person_id: &str, body: crate::models::ProfileViewBuilderTemplate) -> Result<crate::models::ProfileViewQueryResponse, Error<ProfileBuilderError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/profileview", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("PersonId", &person_id.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProfileBuilderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The Tape holds running stream of customer journey events that arrive onto Data Sink from all channels, across mediums. Tape is an append-only, immutable data ledger that can be queried to retrieve snapshot of latest events that moment in time or historically to play-back events as they occurred to understand or analyze Journeys using ML/AI models.  SAS Token Requirements:  - ss=tape  - sp=r
pub async fn read_events(configuration: &configuration::Configuration, authorization: &str, filter: Option<&str>, top: Option<i32>) -> Result<crate::models::TapeReaderResponse, Error<ReadEventsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/events/v1/journey", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = filter {
        local_var_req_builder = local_var_req_builder.query(&[("$filter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReadEventsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The Tape holds running stream of customer journey events that arrive onto Data Sink from all channels - across mediums. Tape is a append-only, immutable data ledger that can be queried to retrieve snapshot of latest events that moment in time or historically to play-back events as they occurred to understand or analyze Journeys using ML/AI models.  SAS Token Requirements:  - ss=tape  - sp=r
pub async fn read_events_by_identity(configuration: &configuration::Configuration, authorization: &str, identity: &str, filter: Option<&str>, top: Option<i32>) -> Result<crate::models::TapeReaderResponse, Error<ReadEventsByIdentityError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/events/v1/journey/{identity}", configuration.base_path, identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = filter {
        local_var_req_builder = local_var_req_builder.query(&[("$filter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("Authorization", authorization.to_string());

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReadEventsByIdentityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Real-time streaming enables API consumers to listen for events as it arrives part of the Journey, these may be transformed, value added / enriched and ready to be consumed or forwarded to an another destination. Optionally accepts $filter to slice/dice further (ex: type eq 'Add to Cart').  SAS Token Requirements:  - ss=stream  - sp=r
pub async fn read_streams(configuration: &configuration::Configuration, sig: Option<&str>, authorization: Option<&str>) -> Result<String, Error<ReadStreamsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/streams", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sig {
        local_var_req_builder = local_var_req_builder.query(&[("sig", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReadStreamsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Real-time streaming enables API consumers to listen for events as it arrives part of the Journey, these may be transformed, value added / enriched and ready to be consumed or forwarded to an another destination. Optionally accepts $filter to slice/dice further (ex: type eq 'Add to Cart').  SAS Token Requirements:  - ss=stream  - sp=r
pub async fn read_streams_by_person(configuration: &configuration::Configuration, person: &str, sig: Option<&str>, authorization: Option<&str>) -> Result<String, Error<ReadStreamsByPersonError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/journey/streams/{person}", configuration.base_path, person=crate::apis::urlencode(person));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sig {
        local_var_req_builder = local_var_req_builder.query(&[("sig", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = authorization {
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReadStreamsByPersonError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

